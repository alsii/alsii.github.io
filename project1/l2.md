---
layout: default
published: true
---
# Еще немного теории

## Пространства имен

Сегодня редкий программный проект не использует готовые компоненты, написанные сторонними разработчиками. Сообщество PHP-разработчиков на сегодняшний день накопило сотни готовых к использованию, протестированных и поддерживаемых компонентов, которые позволяют эффективно решать практически все стандарные задачи возникаюшие при создании приложения. Однако, при использовании любых внешних компонентов возникает проблема конфликта имен. Предположим мы начали писать приложение и создали в нем класс `SortedCollection`. Через какое время, мы решили использовать в нашем проекте внешний компонет SuperComponet разработчика SuperVendor. Скачав и развернув необходимые файлы мы получаем ошибку. Оказывается, SuperVendor также использует в своем компоненте класс с именем `SortedCollection`. Так как имя класса должно быть уникально в рамках приложения, нам придется переименовать наш класс, что может представлять достаточно сложную задачу, если наше приложение уже успело разрастись до серьезных размеров.

Предположим, что мы решились на эти героические усилия и переименовали наш класс. Спустя некоторое время мы решили использовать еще один внешний компонет - MegaComponent разработчика MegaVendor. И тут мы можем с ужасом обнаружить, что и этот разработчик использует класс с именем `SortedCollection`. Теперь между собой конфликтуют по именам классы сторонних разработчиков, и мы мало что можем сделать чтобы разрешить этот конфликт. Чтобы устранить эту проблему первоначально сообществом были разработаны правила именования классов. Согласно этим правилам имя __каждого__ класса должно было включать название разработчика, отделенного символом подчеркивания. Разработчики, чтобы избежать конфликтов имен между классами нескольких своих компонентов могли включать в имя класса имена компонентов. Таким образом классы должны были именоваться следующим образом:

~~~ php
<?php

// класс из компонента SuperComponent разработчика SuperVendor
class SuperVendor_SuperComponent_SortedCollection
{
// ...
}

// класс из компонента NewComponent разработчика SuperVendor
class SuperVendor_NewComponent_SortedCollection
{
// ...
}

// класс из компонента MegaComponent разработчика MegaVendor
class MegdVendor_MegaComponent_SortedCollection
{
// ...
}

// А это наш класс
class MyApplication_SortedCollection
{
// ...1
}
~~~

Такой подход успешно разрешал проблему конфликта имен, но создавал новые. Во-первых, возникали проблемы при изменении названия разработчика или компонента. И если с первым еще можно было мириться, то второе серьезно затрудняло разработку. В предыдущем примере видно что два компонента разработчика SuperVendor используют класс с одинаковым именем. Вполне возможно, что это на самом деле один и тот же класс, просто размещенный в обоих компонентах. Предположим таких дублирующихся классов у разработчика накопилось много, и он чтобы избежать дублирования решил объединть их все в отдельный компонент CoreComponent. Однако, если сделать это, то во __всех__ проектах, которые использовали компоненты этого разработчика, придется поменять название класса во __всех__ местах кода, где он использовался. Чтобы избежать этого необходимо было внести изменения в сам язык. К счастью, решение этой проблемы уже было известно - пространства имен. Они уже использовались в других языках программирования, и появились в PHP начиная c версии 5.3.

Теперь каждый класс можно было отнести к одному из пространств имен. Само имя класса при этом не меняется, а к нему добавляется префикс пространства имен. Префиксы могут быть составными, что позволяет поддерживать иерархические пространства имен. Части перфикса между собой, и весь префикс от имени класса отделяется обратной косой чертой. Имя класса с префиксом пространства имен образуют полное имя класса. Чтобы не писать каждый раз полное имя класса пространство имен может быть объявлено с помощью ключевого слова `namespace`. Все классы, объявленные после этото относятся к указанному пространству имен:

~~~ php
<?
namespace MyApplication

// Пространство имен - MyApplication
// Имя класса - SortedCollection
// Полное имя класса - \MyApplication\SortedCollection

class SortedCollection
{
// ...
}
~~~

Разработчик SuperVendor, который создал компонет SuperConponent может использовать следующие объявления:

~~~ php
<?
namespace SuperVendor\SuperConponent

// Пространство имен - SuperVendor\SuperConponent
// Имя класса - SortedCollection
// Полное имя класса - \SuperVendor\SuperConponent\SortedCollection

class SortedCollection
{
// ...
}
~~~

Если класс принадлежит к текущему пространству имен, можно ссылаться на него используя только имя класса. Иначе нам нужно указывать полное имя класса.

~~~ php
<?
namespace MyApplication

class SortedCollection
{
// ...
}

class Application
{
  public function makeCollections()
  {
    // текущее пространство имен - MyApplication,
    // поэтому SortedCollection без префикса это \MyApplication\SortedCollection
    $myColletcion = new SortedCollection()
    
    // можно ссылаться и по полному имени класса
    $myColletcion = new \MyApplication\SortedCollection()
    
    // а это "чужой" класс
    $superColletcion = new \SuperVendor\SuperComponent\SortedCollection()
  }
}
~~~

Чтобы не загромождать код можно воспользоваться ключевым словом use, чтобы объявить псевдонимы для используемых нами классов. Псевдоним обычно совпадает с именем класса (без префикса пространства имен), но может быть и изменен.

~~~ php
<?
namespace MyProject

//далее можно использовать \SuperVendor\SuperComponent\SortedCollection как SortedCollection
use SuperVendor\SuperComponent\SortedCollection 

//далее можно использовать \MyApplication\SortedCollection как MySortedCollection
use MyApplication\SortedCollection as MySortedCollection

//можно использовать сколько угодно классов из других пространств имен
use MegaVendor\MegaComponent\SortedCollection as MegaSortedCollection

class Application
{
  public function make Collections()
  {
    // это \SuperVendor\SuperComponent\SortedCollection
    $superCollection = new SortedCollection()
  
    // а это \MyApplication\SortedCollection
    $myColletcion = new MySortedCollection()
  
    // а это \MegaVendor\MegaComponent\SortedCollection
    $myColletcion = new MegaSortedCollection()
  }
}
~~~

Таким образом пространства имен позволяют гибко разграничивать области видимости классов и избегать конфликта имен.

## Автозагрузка классов

С некоторых пор хорошим тоном считается размещать каждый класс нашего приложения в отдельном файле. это позволяет быстро находить нужный класс принеобходимости, облегчает работ усистем контроля версий и вообще внисит некоторую упорядоченность в структуру кода. Однако, при таком подходе требуется каким-то образом сообщать интерпретатору, что нужно обрабатывать не только текущий файл, но и другие, код из которых нам необходим. Стандартным для PHP способом слелать это, является директивы `include`, `require`, `require_once`, которые позволяют "включить" в текущий файл код из другого файла. Но с ростом количества файлов, растет количество этих директив в каждом из файлов. Кроме того. при изменении имен файлов или структуры каталогов проекта приходится вносить изменения во __все__ файлы, которые на него ссылаются. Поэтому в PHP закономерно появилась возможность автозагрузки классов. Как это работает: если в процессе выполнения скрипта интерпретатор встречает ссылку на класс, реализации которого нет в подгруженных в настоящий момент файлах (файл с которого началось выполнение скрипта, и все файлы включенные при помощи соответствующих директив), он обращается к функции автозагрузки. Функция автозагрузки - это написанная нами функция, которая зарегистрирована при помощи системной функции spl_autoload_register(). Этой функции передается полное имя класса, и она может попытаться найти файл, в котором реализован данный класс и подгрузить его. В случае неудачи выполнение программы завершится ошибкой.

Чтобы функция автозагрузки могла легко найти файлы классов используются соглашения, касаюшиеся их размещения. В общем случае структура папок повторяет структуры пространства имен. В таком случае функции автозагрузки достаточно знать корневую папку каждого пространства имен верхнего уровня. Тогда полное имя класса легко преобразуется в путь в файловой системе. В "тяжелых" случаях использут карты сопоставления, которые прямо сопоставляют пространства имен папкам файловой системы, а классы - файлам.

~~~
Файловая система:

+--app
|  +--src
|     +--MyApplication
|        +--SortedCollection.php
+--vendor
   +--SuperVendor
   |  +--SuperComponent
   |      +--SortedCollection.php
   +--MegaVendor
      +--MegaComponent
         +--SortedCollection.php
         
Конфигурация функции автозагрузки:

Пространство имен - Папка файловой системы
\MyApplicatioin - app\src
\SuperVendor - vendor
\MegaVendoe - vendor

Результаты поиска
\MyApplication\SortedCollection - app\src\MyApplication\SortedCollection.php
\SuperVendor\SuperComponent\SortedCollection - vendor\SuperVendor\SuperComponent\SortedCollection.php
\MegaVendor\MegaComponent\SortedCollection - vendor\MegaVendor\MegaComponent\SortedCollection.php
~~~
