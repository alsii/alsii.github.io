# Сайт с гостевой книгой

## Немного о пространствах имен

Сегодня редкий программный проект не использует готовые компоненты, написааные сторонними разработчиками. Сообщество PHP-разработчиков на сегодняшний день накопило сотни готовых к использованию, протестированных и поддерживаемых компонентов, ктороые позволяют эффективно решать практически все стандарные задачи возникаюшие при создании приложения. Однако, при использовании любых внешних компонентов возникает проблема конфликта имен. Предположим мы начали писать наше приложение и создали в нем класс `SortedCollection`. Через какое время, мы решили использовать в нашем проекте внешний компонет SuperComponet разработчика SuperVendor. Скачав и развернув необходимые файлы мы получаем ошибку. Оказывается, SuperVendor также использует в своем компоненте класс с именем `SortedCollection`. Так как имя класса должно быть уникально в рамках приложения, нам придется переименовать наш класс, что может представлять достаточно сложную задачу, если наше приложение уже успело разрастись до серьезных размеров.

Предположим, что мы решились на эти героические усилия и переименовали наш класс. Спустя некоторое время мы решили использовать еще один внешний компонет: MegaComponent разработчика MegaVendor. И тут мы можем с ужасом обнаружить, что и этот разработчик использует класс с именем `SortedCollection`. Теперь между собой конфликтуют по именам классы сторонних разработчиков, и мы мало тчо можем сделать чтобы разрешить этот конфликт. Чтобы разрешить эту ситуацию первоначально сообществом были разработаны правила именования классов. Согласно этим правиламимя __каждого__ класса должно было включать название разработчика, отделенного символом подчеркивания. Разработчики, чтобы избежать конфликтов имен между классами разных компонентами могли включать в имя класса имена компонентов. Таким образом классы должны были именоваться следующим образом:

~~~ php
<?php

// класс из компонента SuperComponent разработчика SuperVendor
class SuperVendor_SuperComponent_SortedCollection
{
// ...
}

// класс из компонента NewComponent разработчика SuperVendor
class SuperVendor_NewComponent_SortedCollection
{
// ...
}

// класс из компонента MegaComponent разработчика MegaVendor
class MegdVendor_MegaComponent_SortedCollection
{
// ...
}

// А это наш класс
class MyApplication_SortedCollection
{
// ...1
}
~~~

Такой подход успешно разрешал проблему конфликта имен, но создавал новые. Во-первых, такой подход создавал проблемы при изменении названия разработчика или компонента. И если с первым еще можно было мириться, то второе серьезно затрудняло разработку. В предыдущем примере видно что два компонента разработчика SuperVendor используют класс с одинаковым именем. Вполне возможно, что это на самом деле один и тот же класс, просто размещенный в обоих компонентах. Предположим таких дублтрующихся классов у разработчика накопилось много, и он чтобы избежать дублирования решил объединть их все в отдельный компонент CoreComponent. Однако, если сделать это, то во __всех__ проектах, которые использовали компоненты этого разработчика придется поменять название класса во __всех__ местах кода, где он использовался. Чтобы избежать этих проблем (или по крайней мере частично их смягчить) необходимо было внести изменения в сам язык. К счастью, решение этой проблемы уже было известно - пространства имен.

Теперь каждый класс можно было отнести к одному из пространств имен. Само имя класса при этом не меняется, а к нему добавляется префикс пространства имен. Префиксы могут быть составными, что позволяет поддерживать иерархические пространства имен. Части перфикса между собой, и весь префикс от имени класса отделяется обратной косой чертой. Имя класса с префиксом пространства имен образуют полное имя класса. Чтобы не писать каждый раз полное имя класса пространство имен может быть объявлено с помощью ключевого слова `namespace`. Все классы, объявленные после этото относятся к указанному пространству имен:

~~~ php
<?
namespace MyApplication

// Пространство имен - MyApplication
// Имя класса - SortedCollection
// Полное имя класса - \MyApplication\SortedCollection

class SortedCollection
{
// ...
}
~~~

Разработчик SuperVendor, который создал компонет SuperConponent может использовать следующие объявления:

~~~ php
<?
namespace SuperVendor\SuperConponent

// Пространство имен - SuperVendor\SuperConponent
// Имя класса - SortedCollection
// Полное имя класса - \SuperVendor\SuperConponent\SortedCollection

class SortedCollection
{
// ...
}
~~~

Если класс принадлежит к текущему пространству имен, можно ссылаться на него используя только имя класса. Иначе нам нужно указывать полное имя класса.

~~~ php
<?
namespace MyApplication

class SortedCollection
{
// ...
}

class Application
{
  public function makeCollections()
  {
    // текущее пространство имен - MyApplication,
    // поэтому SortedCollection без префикса это \MyApplication\SortedCollection
    $myColletcion = new SortedCollection()
    
    // можно ссылаться и по полному имени класса
    $myColletcion = new \MyApplication\SortedCollection()
    
    // а это "чужой" класс
    $superColletcion = new \SuperVendor\SuperComponent\SortedCollection()
  }
}
~~~

Чтобы не загромождать код можно воспользоваться ключевым словом use, чтобы объявить псевдонимы для используемых нами классов. Псевдоним обычно совпадает с именем класса (без префикса пространства имен), но может быть и изменен.

~~~ php
<?
namespace MyProject

//далее можно использовать \SuperVendor\SuperComponent\SortedCollection как SortedCollection
use SuperVendor\SuperComponent\SortedCollection 

//далее можно использовать \MyApplication\SortedCollection как MySortedCollection
use MyApplication\SortedCollection as MySortedCollection

//можно использовать сколько угодно классов из других пространств имен
use MegaVendor\MegaComponent\SortedCollection as MegaSortedCollection

class Application
{
  public function make Collections()
  {
    // это \SuperVendor\SuperComponent\SortedCollection
    $superCollection = new SortedCollection()
  
    // а это \MyApplication\SortedCollection
    $myColletcion = new MySortedCollection()
  
    // а это \MegaVendor\MegaComponent\SortedCollection
    $myColletcion = new MegaSortedCollection()
  }
}
~~~

Таким образом пространства имен позволяют гибко разграничиватьобласти видимости классов и избегать конфликта имен.

## Автозагрузка классов

