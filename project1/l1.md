---
layout: default
published: true
---
# Использование PHP

## Задание

Числа от 1 до 100 раместить в виде таблицы размером 10х10 клеток.
Границы между ячейками в 1 пиксель толщиной, желтого цвета.
Цвет, размер и шрифт, которым написаны числа - по усмотрению.
У строк должен чередоваться фон в порядке: белый-синий-красный.
В четных столбцах числа должны быть выделены жирным шрифтом.
Числа, которые делятся на 5 выделить зеленым цветом, которые делятся на 7 - курсивом.

## Решение

### Таблица стилей

Чтобы управлять внешним видом ячеек таблицы сформируем таблицу стилей. Стили назовем используя осмысленные обозначения, чтобы затем можно было просто менять оформление нашей таблицы.

~~~ css
.row0 {
  background-color: white; /* строка 0 */
}
.row1 {
  background-color: lightblue;  /* строка 1 */
}
.row2 {
  background-color: lightred;  /* строка 2 */
}
.col-even {
  font-weight: bold;  /* четные столбцы */
}
.x5 {
  color: green;  /* число делится на 5 */
}
.x7 {
  font-style: italic;  /* число делится на 7 */
}
~~~

Сохраним нашу таблицу стилей в файл `style.css`. Затем мы сможем использовать его в нашей программе.

### Заготовка HTML-страницы

В результате работы нашей программы должна получиться cтраница на HTML. Создадим заготовку нашей страницы, в которую затем поместим текст нашего PHP-скрипта.

~~~ html
<!DOCTYPE html>
<html>
    <head>
        <link href="style.css" rel="stylesheet">
        <title>Color Table</title>
        <?php
        ?>
    </head>
    <body>
        <h1>Colot Table</h1>
    </body>
</html>
~~~

Скрипт будет размещаться меджу <?php и ?>

### Подготовим таблицу

Для вывода таблицы используем два вложеных цикла `for`. Внешний цикл формирует строки таблицы, внутренний - ячейки в строках, из которыз образуются столбцы. Для вывода HTML используем `echo`.

~~~ php
<?php

define(ROWS, 10);
define(COLS, 10); 

echo "<table border=\"1\">\n";

for ($tr = 1; $tr <= ROWS; $tr++){ 
  echo "<tr>\n";
    for ($td = 1; $td <= COLS; $td++){
      $value = tr*td;
      echo "<td>$value</td>";
    }
    echo "</tr>\n";
}
echo "</table>\n";
?>
~~~

### Раскрашивание строк

Для раскрашивания строк применим один из созданных нами стилей к соответствующим строкам таблицы. Для этого добавим в тег `<tr>` атрибут `class` со значением, соответствующим нужному стилю. Для определения нужного стиля используем оператор `%` (остаток от деления). Для выбора нужного значения используем автоматическое преобразование числовых значений в соответствующие строки при использовании оператора `.` (конкатенация строк). В результате наша программа будет выглядеть так:

~~~ php
<?php

define(ROWS, 10);
define(COLS, 10); 

echo "<table border=\"1\">\n";

for ($tr = 1; $tr <= ROWS; $tr++){ 
    echo "<tr>\n";

    $trClass = "row" . ($tr % 3);

    echo "<tr class=\"$trClass\">\n";
    for ($td = 1; $td <= COLS; $td++){
      $value = tr*td;
      echo "<td>$value</td>";
    }
    echo "</tr>\n";
}
echo "</table>\n";
?>
~~~

### Выделение четных столбцов

Для выделения четных столбцов будем добавлять атрибут `class` со значением, соответствующим нужному стилю в тег `<td>`. Используем те же приемы, что мы использовали для строк таблицы. В результате получим:

~~~ php
<?php

define(ROWS, 10);
define(COLS, 10); 

echo "<table border=\"1\">\n";
echo "<tr>\n";

for ($tr = 1; $tr <= ROWS; $tr++){ 

    $trClass = "row" . ($tr % 3);

    echo "<tr class=\"$trClass\">\n";
    for ($td = 1; $td <= COLS; $td++){
        $value = tr*td;
        
        if(0 == $td % 2) {
            $tdClass = "col-even";
        }
      
      echo "<td class=\"$tdClass\">$value</td>";
    }
    echo "</tr>\n";
}
echo "</table>\n";
?>
~~~

### Предварительные итоги

Наша программа выполняет два из пяти заданий. Посмотрим, однако на HTML-текст, который получается в результате ее выполнения. Для нечетных столбцов тег `<tr>` выглядит следующим образом:

~~~ html
<tr class="">
~~~

хотя этот тег отображается корректно, хотелось бы избавиться от атрибута `class` с пустым значением. Добавим дополнительную проверку:

~~~ php
<?php

define(ROWS, 10);
define(COLS, 10); 

echo "<table border=\"1\">\n";
echo "<tr>\n";

for ($tr = 1; $tr <= ROWS; $tr++){ 

    $trClass = "row" . ($tr % 3);

    echo "<tr class=\"$trClass\">\n";
    for ($td = 1; $td <= COLS; $td++){
        $value = tr*td;
        
        if(0 == $td % 2) {
            $tdClass = "col-even";
        }
      
        if("" != $tdClass) {
          $tdClass = "class=\"$tdClass\"";
        }
        echo "<td$tdClass>$value</td>";
    }
    echo "</tr>\n";
}
echo "</table>\n";
?>
~~~

На что нужно обратить внимание:

* Мы сохраняем значение, полученное с помощью переменной `$tdClass` обратно в эту же переменную. Ничего удивительного в этом нет, так же мы поступаем когда пишем, например, `$i = $i + 5`. Просто в данном случае переменная у нас содержит строковое значение и используется операция подстановки в строку `"class=\"$tdClass\""`. Символы обратного слеша используются для экранирования двойных кавычек.
* В функции echo также используется операция в строку, только подставляются значения двух переменных.

Теперь теги `<tr>` в нечетных строках таблицы не содержат "пустого" атрибута, что нам и было нужно. Можно двигаться дальше.

### Раскрашиваем числа кратные пяти и семи

При выполнении этой задачи мы обнаружим, что в некоторых случаях нам необходимо присвоить одному тегу несколько классов CSS. Атрибут `class` в этом случае должен выглядеть следующим образом `class="class1 class2"`. Напрашивется следующее решение:

~~~ php
<?php
    if(0 == $td % 2) {
        $tdClass = "col-even";
    }
    
    if(($td*$tr) % 5) {
        $tdClass .= " x5"
    }

    if(($td*$tr) % 7) {
        $tdClass .= " x7"
    }
?>
~~~

Однако, при этом мы обнаружим, что для делящихся на 5 и 7 чисел, которые расположены в нечентых столбцах полученный HTML код выглядит следующим образом: `<td class=" x5">` и `<td class=" x7">` соответственно. Этот код нормально интерпретируется браузерами, но лишний пробел выглядит неэстетично и кроме того увеличивает объем страницы. Избавиться от него можно различными способами, но мы воспользуемся этой возможностью. чтобы разобраться как использовать массивы.

### Массивы (лирическое отступление)

Массивы в PHP - чрезвычайно мощное средство. Они объединяют в себе возможности, которые в других языках реализуются множеством различных средств (массивы, хэши, динамические структуры: коллекции (в том числе сортируемые), списки, деревья и мн. др.). Этому способствуют следующие их особенности:
* массивы являются одновременно обычными (с числовыми индексами) и ассоциативными
* их элементы могут содержать произвольные значения (в том числе другие массивы, что позволяет создавать массивы произвольной размерности).
* массивы являются динамическими, т.е. элементы массивов можно создавать и уничтожать во время выполнения

Кроме того в PHP имеется богатая библиотека функций для работы с массивами, которая позволяет проводить с массивами множество манипуляций (сортировка, поиск по ключам и значениям, слияние и разбиение массивов и т.п.). Кроме того, конструкции языка позволяют перебирать элементы массивов вне зависимости от того, являются ли ключи числовыми или строковыми.

В нашем примере мы воспользуемся возможностью динамического создания значений в массиве и функцией преобразования элементов массива в строку (конкатенация элементов).

Поскольку PHP - язык с динамической типизацией специяльно объявлять переменную как массив не требуется. Вместо этого используется функция (точнее - специальная языковая конструкция), кторорая возврящает массив, значениями которого будут переданные ей аргументы. Выглядит это так:
~~~ php
$a = array(); // Пустой массив, не содержит ни одного элемента
$a = array(10, 20, 30, 40); // Обычный массив: содержит четыре элемента с индексами 0, 1, 2, 3 соответственно.
$a = array(10, 'Hello', 30, 'World'); // Обычный массив: содержит числовые и строковые значения.

$a = array( 5 => 10, 6 => 20, 7 => 30, 8 => 40); // Обычный массив: содержит четыре элемента с индексами 5, 6, 7, 8 соответственно. "Толстая" или "жирная" стрелка => разделяет индекс и значение элемента массива.

$a = array( 5 => 10, 20, 30, 40); // то же самое, что и в предыдущем примере, нумерация индекса "продолжается"
$a = array( 5 => 10, 20, 10 => 30, 40); // так тоже можно. Индексы: 5, 6, 10, 11.

$a = array( 'one' => 1, 'two' => 2, 'three' => 3); // строковые ключи, числовые значения
$a = array( 1 => 'one', 2 => 'two', 3 => 'three'); // наоборот
$a = array( 'one' => 'eins', 'two' => 'zwei', 'three' => 'drei'); // так тоже можно
$a = array( 'one' => 'eins', 'two' => 'zwei', 1 => 'one', 2 => 'two'); // и так
$a = array( 'one' => 1, 1 => 'one', 'two' => 2, 2 => 'two'); // и даже так
$a = array( 'one' => 1, 1 => 'one', 'two' => 2, 'two'); // то же, что и выше - автонумерация

$a = array( array(1 => 'one', 'two'), array(3, 'four' => 4, 'five')); // элементами массива могут быть массивы, количество элементов не имеет значения.
~~~

Для обращения к элементу массива используются квадратные скобки. Почти как С/С++. "Почти" потому, что индексом может быть не только число, но и строка.

~~~ php
$a = array(10, 20, 30, 40);
echo $a[2]; // печатает 30

$a[1] = 21; // теперь массив выглядит так: 10, 21, 30, 40

$a = array( 'one' => 1, 'two' => 2, 'three' => 3);
$a['one'] => 'eins';
$a['two'] => 'zwei';
$a['three'] => 'drei'; // поменяли числовые значения на строковые

$a['four'] = 'vier'; // Добавили в массив новое строковое значение со строковым ключом
$a[4] = 'vier'; // Добавили в массив новое строковое значение с числовым ключом

$a = array();
$a[] = 'zero'; // Добавили в массив новое значение с "очередным" числовым ключом - 0, т.к. массив был пустой.
$a[] = 'one'; // И еще одно. Ключ - 1
$a[] = 'two'; // И еще одно. Ключ - 2
$a[5] = 'five'; // Ключ - 5
$a[] = 'six'; // И еще одно. Ключ - 6, следующий за 5.
$a[4] = 'four'; // А я четвертую нашел!!! :)
~~~

### Возвращаемся к раскрашиванию

Как уже говорилось в PHP есть богатейший набор функций для работы с массивами. Самое приятное, что они выполнены как бинарные библиотеки к самому PHP, т.е. всегдя доступны для использования и работают очень быстро. Для нашей задачи идеально подходит функция implode, которая "собирает" элементы массива в строку, используя указанный при вызове разделитель. Cинтаксис функции прост: `string implode ( string $glue , array $pieces )`, где `$glue` - разделитель, `$pieces` - массив. Следут особо отметить, что функция превосходно работает как с пустым массивом (возвращает пустую строку), так и с массивом, состоящим из одного элемента (его и возвращает). Если в массиве содержатся нестроковые элементы PHP преобразует каджый и них в строковое представление (по крайней мере попытается сделать это наилучшим образом). Как же мы можем это использовать? Очень просто! Сначала сформируем массив, содержащий нужные нам классы, а потом "склеим" его элементы в строку используя в качестве разделителя пробел.

~~~ php
<?php

define(ROWS, 10);
define(COLS, 10); 

echo "<table border=\"1\">\n";
echo "<tr>\n";

for ($tr = 1; $tr <= ROWS; $tr++){ 

    $trClass = "row" . ($tr % 3);

    echo "<tr class=\"$trClass\">\n";
    for ($td = 1; $td <= COLS; $td++){
        $value = tr * td;
        
        $tdClass = array();
        if(0 == $td % 2) {
            $tdClass[] = "col-even";
        }
        if(0 == $value % 5) {
            $tdClass[] = "x5";
        }
        if(0 == $value % 7) {
            $tdClass[] = "x7";
        }

        $tdClass = implode(' ', $tdClass); // результат в виде строки сохранили в ту же переменную. Вообще, так делать категорически не рекомендуется. Так что только в учебных целях :)
      
        if("" != $tdClass) {
          $tdClass = "class=\"$tdClass\"";
        }
        echo "<td$tdClass>$value</td>";
    }
    echo "</tr>\n";
}
echo "</table>\n";
?>
~~~

Вот теперь наш HTML выглядит приятно и аккуратно :) Задача решена. Но мы на этом не остановимся, а попробуем решить ее более современным способом. Вообще это действие называется "__рефакторинг__". Обычно его определяют как "изменение кода, не приводящее к изменению поведения программы, но улучшающее внутреннюю структуру, читаемость и понимаемость кода и служащее для упрощения его сопровождения и дальнейшего развития". Следует отличать __рефакторинг__ (относительно новое понятие), от __оптимизации__ (существует очень давно), которая также не влияет на результаты работы программы, но увеличивает быстродействие и/или уменьшает требования к используемой памяти.


